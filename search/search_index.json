{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Permission-graph provides an authorization framework for granular access control.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Fundamentally, permission-graph helps authorize Actors to take Actions on Resources. Take the following example of an actor named Alice and a  simple file system. </p> <p>The graph defines a ResourceType named  \"Document\" with two Actions:  <code>ViewDocument</code> and <code>EditDocument</code>.</p> <p>There are two Resources created, each representing a file in the file  system: <code>cc_info.csv</code> and <code>passwords.txt</code>. Each resource has its own copy of the actions defined by its resource type.</p> <p>Finally, an Actor named \"Alice\" is defined, with \"Allow\" links to the actions of <code>cc_info.csv</code>. The allow link indicates that Alice is authorized to perform the ViewDocument and EditDocument actions on the file. Meanwhile, the missing links to the actions of <code>passwords.txt</code> indicate Alice does not have permission to perform those actions.</p> DiagramPython <pre><code>flowchart\n    alice[actor:Alice]\n    document_type[resource_type:Document]\n    document[resource:Document:cc_info.csv]\n    document2[resource:Document:passwords.txt]\n    view_d1[action:ViewDocument]\n    edit_d1[action:EditDocument]\n    view_d2[action:ViewDocument]\n    edit_d2[action:EditDocument]\n    document--&gt;|member of|document_type\n    document2--&gt;|member of|document_type\n\n    view_d1--&gt;|member of|document\n    edit_d1--&gt;|member of|document\n    view_d2--&gt;|member of|document2\n    edit_d2--&gt;|member of|document2\n\n    alice--&gt;|allow|view_d1\n    alice--&gt;|allow|edit_d1\n\n\n    style alice fill:#227aff,color:#FFF\n    style view_d1 fill:#0F0\n    style edit_d1 fill:#0F0\n    style view_d2 fill:#0F0\n    style edit_d2 fill:#0F0\n    style document fill:#eef95a\n    style document2 fill:#eef95a\n    style document_type fill:#f8b1de\n    linkStyle 7 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 6 stroke:#0f0,stroke-width:4px,color:green;</code></pre> Alice's Document<pre><code>from permission_graph import PermissionGraph\nfrom permission_graph.structs import (\n    Actor,\n    Resource,\n    ResourceType,\n    Action\n)\n\npg = PermissionGraph()\n\nalice = Actor(name=\"Alice\")\npg.add_actor(alice)\n\ndocument_type = ResourceType(name=\"Document\", actions=[\"ViewDocument\", \"EditDocument\"])\npg.add_resource_type(document_type)\n\ncc_info = Resource(name=\"cc_info.csv\", resource_type=\"Document\")\npg.add_resource(cc_info)\npasswords = Resource(name=\"passwords.txt\", resource_type=\"Document\")\npg.add_resource(passwords)\n\nview_cc_info = Action(name=\"ViewDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\nedit_cc_info = Action(name=\"EditDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\nview_passwords = Action(name=\"ViewDocument\", resource_type=\"Document\", resource=\"passwords.txt\")\nedit_passwords = Action(name=\"EditDocument\", resource_type=\"Document\", resource=\"passwords.txt\")\n\npg.allow(alice, view_cc_info)\npg.allow(alice, edit_cc_info)\n\nassert pg.action_is_authorized(alice, view_cc_info) is True, \"Alice is authorized to view cc_info\"\nassert pg.action_is_authorized(alice, edit_cc_info) is True, \"Alice is authorized to edit cc_info\"\nassert pg.action_is_authorized(alice, view_passwords) is False, \"Alice is not authorized to view passwords\"\nassert pg.action_is_authorized(alice, edit_passwords) is False, \"Alice is not authorized to edit passwords\"\n</code></pre>"},{"location":"#groups","title":"Groups","text":"<p>Groups are used to share permissions with many users.</p> <p>Continuing from the example above, say we add another user named Bob whom we also wish to have full access to the <code>cc_info.csv</code> document. </p> <p>One way to accomplish this is to add the same permissions that we did for Alice.</p> DiagramPython <pre><code>flowchart\n    alice[actor:Alice]\n    bob[actor:Bob]\n    document[resource:cc_info.csv]\n    view[action:ViewDocument]\n    edit[action:EditDocument]\n    document_type[resource_type:Document]\n\n    document--&gt;|member of|document_type\n\n    view--&gt;|member of|document\n    edit--&gt;|member of|document\n\n    alice--&gt;|allow|view\n    alice--&gt;|allow|edit\n    bob--&gt;|allow|view\n    bob--&gt;|allow|edit\n\n\n    style alice fill:#227aff,color:#FFF\n    style bob fill:#227aff,color:#FFF\n    style view fill:#0F0\n    style edit fill:#0F0\n    style document fill:#eef95a\n    style document_type fill:#f8b1de\n    linkStyle 3 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 4 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 5 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 6 stroke:#0f0,stroke-width:4px,color:green;</code></pre> Two users<pre><code>from permission_graph import PermissionGraph\nfrom permission_graph.structs import (\n    Actor,\n    Resource,\n    ResourceType,\n    Action\n)\n\npg = PermissionGraph()\n\nalice = Actor(name=\"Alice\")\npg.add_actor(alice)\n\ndocument_type = ResourceType(name=\"Document\", actions=[\"ViewDocument\", \"EditDocument\"])\npg.add_resource_type(document_type)\n\nbob = Actor(name=\"Bob\")\npg.add_actor(bob)\n\ndocument = Resource(name=\"cc_info.csv\", resource_type=\"Document\")\npg.add_resource(document)\n\nview_cc_info = Action(name=\"ViewDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\nedit_cc_info = Action(name=\"EditDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\n\npg.allow(alice, view_cc_info)\npg.allow(alice, edit_cc_info)\n\npg.allow(bob, view_cc_info)\npg.allow(bob, edit_cc_info)\n\nassert pg.action_is_authorized(alice, view_cc_info) is True, \"Alice is authorized to view cc_info\"\nassert pg.action_is_authorized(alice, edit_cc_info) is True, \"Alice is authorized to edit cc_info\"\nassert pg.action_is_authorized(bob, view_cc_info) is True, \"Bob is authorized to view cc_info\"\nassert pg.action_is_authorized(bob, edit_cc_info) is True, \"Bob is authorized to edit cc_info\"\n</code></pre> <p>This may work fine for some applications, but Groups provide a means to share the same set of permission policies among many users.</p> DiagramPython <pre><code>flowchart\n    alice[actor:Alice]\n    bob[actor:Bob]\n    accountants[group:Accountants]\n    document[resource:cc_info.csv]\n    view[action:ViewDocument]\n    edit[action:EditDocument]\n    document_type[resource_type:Document]\n\n    document--&gt;|member of|document_type\n\n    view--&gt;|member of|document\n    edit--&gt;|member of|document\n\n    alice--&gt;|member of|accountants\n    bob--&gt;|member of|accountants\n\n    accountants--&gt;|allow|view\n    accountants--&gt;|allow|edit\n\n    style alice fill:#227aff,color:#FFF\n    style bob fill:#227aff,color:#FFF\n    style view fill:#0F0\n    style edit fill:#0F0\n    style document fill:#eef95a\n    style document_type fill:#f8b1de\n    style accountants fill:#fdebdf\n    linkStyle 3 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 4 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 5 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 6 stroke:#0f0,stroke-width:4px,color:green;</code></pre> Groups<pre><code>from permission_graph import PermissionGraph\nfrom permission_graph.structs import (\n    Actor,\n    Resource,\n    ResourceType,\n    Action,\n    Group\n)\n\npg = PermissionGraph()\n\nalice = Actor(name=\"Alice\")\npg.add_actor(alice)\n\ndocument_type = ResourceType(name=\"Document\", actions=[\"ViewDocument\", \"EditDocument\"])\npg.add_resource_type(document_type)\n\nbob = Actor(name=\"Bob\")\npg.add_actor(bob)\n\naccountants = Group(name=\"Accountants\")\npg.add_group(accountants)\n\npg.add_actor_to_group(alice, accountants)\npg.add_actor_to_group(bob, accountants)\n\ndocument = Resource(name=\"cc_info.csv\", resource_type=\"Document\")\npg.add_resource(document)\n\nview_cc_info = Action(name=\"ViewDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\nedit_cc_info = Action(name=\"EditDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\n\npg.allow(accountants, view_cc_info)\npg.allow(accountants, edit_cc_info)\n\nassert pg.action_is_authorized(alice, view_cc_info) is True, \"Alice is authorized to view cc_info\"\nassert pg.action_is_authorized(alice, edit_cc_info) is True, \"Alice is authorized to edit cc_info\"\nassert pg.action_is_authorized(bob, view_cc_info) is True, \"Bob is authorized to view cc_info\"\nassert pg.action_is_authorized(bob, edit_cc_info) is True, \"Bob is authorized to edit cc_info\"\n</code></pre>"},{"location":"#deny-permissions","title":"Deny Permissions","text":"<p>We've already seen two of the three supported edge types in permission-graph:</p> <ul> <li><code>MEMBER_OF</code>: Indicates one vertex is a member of another (e.g. an actor is a member of a group)</li> <li><code>ALLOW</code>: Indicates one vertex is allowed to perform some action</li> </ul> <p>The third edge type is <code>DENY</code>, which is analagous to <code>ALLOW</code> but explicitly does not allow an actor to perform some action.</p> <p>To understand why this is useful, we continue from our example above. Bob and Alice both belong to the Accountants group, which grants them full access to  the \"cc_info.csv\" document.</p> <p>But what if we wanted to revoke Bob's permission to share the document with others? One approach is to go back to managing each actor's permisisons individually.</p> <p>However, we can also use a <code>DENY</code> edge to accomplish the same end, while keeping our graph lean.</p> DiagramPython <pre><code>flowchart\n    alice[actor:Alice]\n    bob[actor:Bob]\n    accountants[group:Accountants]\n    document[resource:cc_info.csv]\n    view[action:ViewDocument]\n    edit[action:EditDocument]\n    document_type[resource_type:Document]\n\n    document--&gt;|member of|document_type\n\n    view--&gt;|member of|document\n    edit--&gt;|member of|document\n\n    alice--&gt;|member of|accountants\n    bob--&gt;|member of|accountants\n\n    accountants--&gt;|allow|view\n    accountants--&gt;|allow|edit\n\n    bob--&gt;|deny|edit\n\n\n    style alice fill:#227aff,color:#FFF\n    style bob fill:#227aff,color:#FFF\n    style view fill:#0F0\n    style edit fill:#0F0\n    style document fill:#eef95a\n    style document_type fill:#f8b1de\n    style accountants fill:#fdebdf\n    linkStyle 3 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 4 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 5 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 6 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 7 stroke:#f00,stroke-width:4px,color:red;</code></pre> Deny permissions<pre><code>from permission_graph import PermissionGraph\nfrom permission_graph.structs import (\n    Actor,\n    Resource,\n    ResourceType,\n    Action,\n    Group\n)\n\npg = PermissionGraph()\n\nalice = Actor(name=\"Alice\")\npg.add_actor(alice)\n\nbob = Actor(name=\"Bob\")\npg.add_actor(bob)\n\ndocument_type = ResourceType(name=\"Document\", actions=[\"ViewDocument\", \"EditDocument\"])\npg.add_resource_type(document_type)\n\naccountants = Group(name=\"Accountants\")\npg.add_group(accountants)\n\npg.add_actor_to_group(alice, accountants)\npg.add_actor_to_group(bob, accountants)\n\ndocument = Resource(name=\"cc_info.csv\", resource_type=\"Document\")\npg.add_resource(document)\n\nview_cc_info = Action(name=\"ViewDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\nedit_cc_info = Action(name=\"EditDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\n\npg.allow(accountants, view_cc_info)\npg.allow(accountants, edit_cc_info)\npg.deny(bob, edit_cc_info)\n\nassert pg.action_is_authorized(alice, view_cc_info) is True, \"Alice is authorized to view cc_info\"\nassert pg.action_is_authorized(alice, edit_cc_info) is True, \"Alice is authorized to edit cc_info\"\nassert pg.action_is_authorized(bob, view_cc_info) is True, \"Bob is authorized to view cc_info\"\nassert pg.action_is_authorized(bob, edit_cc_info) is False, \"Bob is not authorized to edit cc_info\"\n</code></pre> <p>There are two valid paths from Bob to the <code>EditDocument</code> permission. </p> <ul> <li>Bob --(member_of)-&gt; Accountants --(allow)-&gt; EditDocument</li> <li>Bob --(deny)-&gt; EditDocument</li> </ul> <p>Through his membership in the Accountants group, he is allowed to share the document. However, the most direct path between Bob and the document denies access, so Bob will not be allowed to share the document with others.</p> <p>This example demonstrates a key principle of permission-graph: The most direct permission wins.</p> <p>The <code>action_is_authorized</code> method works by finding the shortest path from the actor to the action. The cases are handled as follows:</p> <ul> <li>If there is no path from actor to the action, the action is not authorized.</li> <li>If there is a true shortest path from actor to the action, the action is authorized     if the edge to the action along that path is an ALLOW edge. If the edge is     a DENY edge, the action is not authorized.</li> <li> <p>If there are multiple paths of equal length such that there is no one shortest,     the action uses the <code>TieBreakerPolicy</code> to authorize the action. The two     policies are:</p> <ol> <li><code>ANY_ALLOW</code>: Allow the action if any of the shortest paths allow the action</li> <li><code>ALL_ALLOW</code>: Allow the action only if all the shortest paths allow the action</li> </ol> <p>The default policy is <code>ANY_ALLOW</code>, but can be set when instantiating the PermissionGraph.</p> TieBreakerPolicy<pre><code>from permission_graph import PermissionGraph\nfrom permission_graph.structs import TieBreakerPolicy\n\npg = PermissionGraph(tie_breaker_policy=TieBreakerPolicy.ALL_ALLOW)\n</code></pre> </li> </ul>"},{"location":"#action-propagation","title":"Action Propagation","text":"<p>Similar to how groups provide a mechanism to bulk apply permissions for actors, action propagation allows access to one action to also grant access to  a different action.</p> <p>As one example, consider adding a new resource type to our graph named <code>Directory</code> to represent a container for <code>Document</code> resources. </p> <p>In this case, when user is granted permission to read a directory we expect the to be granted similar permissions on the files within that directory. If a user has \"Read\" access to a directory, they should also have \"Read\" access to the files within that directory.</p> <p>PermisisonGraph doesn't force this \"action propagation\" behavior, but it does provide a mechanism to easily implement it if desired.</p> <p>For simplicity, only the view permission is shown here.</p> DiagramPython <pre><code>flowchart\n    alice[actor:Alice]\n    directory_type[resource_type:Directory]\n    directory[resource:Directory:Private]\n    document_type[resource_type:Document]\n    document[resource:Document:cc_info.csv]\n    view_document[action:ViewDocument]\n    view_directory[action:ViewDirectory]\n\n\n    directory--&gt;|member of|directory_type\n    document--&gt;|member of|document_type\n\n    view_document--&gt;|member of|document\n    view_directory--&gt;|member of|directory\n\n    view_directory--&gt;|allow|view_document\n\n    alice--&gt;|allow|view_directory\n\n    style alice fill:#227aff,color:#FFF\n    style view_document fill:#0F0\n    style view_directory fill:#0F0\n    style document fill:#eef95a\n    style document_type fill:#f8b1de\n    style directory fill:#eef95a\n    style directory_type fill:#f8b1de\n    linkStyle 4 stroke:#0f0,stroke-width:4px,color:green;\n    linkStyle 5 stroke:#0f0,stroke-width:4px,color:green;</code></pre> Alice's Directory<pre><code>from permission_graph import PermissionGraph\nfrom permission_graph.structs import (\n    Actor,\n    Resource,\n    ResourceType,\n    Action\n)\n\npg = PermissionGraph()\n\nalice = Actor(name=\"Alice\")\npg.add_actor(alice)\n\ndocument_type = ResourceType(name=\"Document\", actions=[\"ViewDocument\"])\npg.add_resource_type(document_type)\ndirectory_type = ResourceType(name=\"Directory\", actions=[\"ViewDirectory\"])\npg.add_resource_type(directory_type)\n\ndocument = Resource(name=\"cc_info.csv\", resource_type=\"Document\")\npg.add_resource(document)\nview_cc_info = Action(name=\"ViewDocument\", resource_type=\"Document\", resource=\"cc_info.csv\")\n\ndirectory = Resource(name=\"Private\", resource_type=\"Directory\")\npg.add_resource(directory)\nview_directory = Action(name=\"ViewDirectory\", resource_type=\"Directory\", resource=\"Private\")\n\npg.allow(view_directory, view_cc_info)\npg.allow(alice, view_directory)\n\nassert pg.action_is_authorized(alice, view_cc_info) is True, \"Alice is authorized to view cc_info\"\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>permission_graph<ul> <li>backends<ul> <li>base</li> <li>igraph</li> </ul> </li> <li>permission_graph</li> <li>structs</li> </ul> </li> </ul>"},{"location":"reference/permission_graph/","title":"permission_graph","text":"<p>A graph based authorization framework.</p> <p>The permissions graph consists of Vertices and Edges.</p> <p>Vertices</p> <ul> <li><code>ResourceType</code>: a type definition for resources describing its supported actions</li> <li><code>Resource</code>: a resource with actions requiring authorization</li> <li><code>Action</code>: an action on a resource</li> <li><code>Actor</code>: an identity that will take actions on resources</li> <li><code>Group</code>: a named collection of <code>Actors</code> with shared permission policies</li> </ul> <p>Edges</p> <ul> <li><code>MemberOf</code>: indicates membership in a collection<ul> <li><code>Actor -&gt; MemberOf -&gt; Group</code></li> <li><code>Action -&gt; MemberOf -&gt; Resource</code></li> <li><code>Resource -&gt; MemberOf -&gt; ResourceType</code></li> </ul> </li> <li><code>Allow</code>: indicates positive permission to act on a resource<ul> <li><code>Actor|Group|Action -&gt; Allow -&gt; Action</code></li> </ul> </li> <li><code>Deny</code>: indicates negative permission to act on a resource<ul> <li><code>Actor|Group|Action -&gt; Deny -&gt; Action</code></li> </ul> </li> </ul>"},{"location":"reference/permission_graph/#permission_graph--authorizing-access","title":"Authorizing Access","text":"<p>Authorization to act on a resource is decided by finding the shortest path between an actor and the action to be performed. If that shortest path is an ALLOW rule,  the actor is authorized. If that shortest path is a DENY rule, or if there is no path between the actor and the action, the actor is not authorized.</p> <p>In the event there is a tie for shortest path, the access will be denied only if all shortest paths are DENY rules. This behavior can be controlled when initializing the permission graph via the <code>tie_breaker_policy</code> parameter.</p>"},{"location":"reference/permission_graph/permission_graph/","title":"permission_graph","text":""},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph","title":"<code>PermissionGraph</code>","text":"Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>class PermissionGraph:\n    def __init__(\n        self, backend: PermissionGraphBackend = None, tie_breaker_policy: TieBreakerPolicy = TieBreakerPolicy.ANY_ALLOW\n    ) -&gt; None:\n        \"\"\"Initialize a new PermissionGraph.\"\"\"\n        if backend is None:\n            backend = IGraphMemoryBackend()\n        self.backend = backend\n        self.tie_breaker_policy = tie_breaker_policy\n        self._resource_type_map = {}\n\n    def add_actor(self, actor: Actor | str) -&gt; None:\n        \"\"\"Add a actor to the permission graph.\"\"\"\n        self.backend.add_vertex(actor)\n\n    def remove_actor(self, actor: Actor) -&gt; None:\n        \"\"\"Remove a actor from the permission graph.\"\"\"\n        self.backend.remove_vertex(actor)\n\n    def add_resource_type(self, resource_type: ResourceType):\n        \"\"\"Register a resource type to the permission graph.\"\"\"\n        self.backend.add_vertex(resource_type, actions=resource_type.actions)\n\n    def remove_resource_type(self, resource_type: ResourceType):\n        \"\"\"Remove a resource type from the permission graph.\"\"\"\n        for resource in self.backend.get_vertices_to(resource_type):\n            self.remove_resource(resource)\n        self.backend.remove_vertex(resource_type)\n\n    def add_resource(self, resource: Resource) -&gt; None:\n        \"\"\"Add a resource to the permission graph.\"\"\"\n        resource_type = self.backend.vertex_factory(f\"resource_type:{resource.resource_type}\")\n        self.backend.add_vertex(resource)\n        self.backend.add_edge(EdgeType.MEMBER_OF, resource, resource_type)\n        for action_name in resource_type.actions:\n            action = Action(name=action_name, resource_type=resource.resource_type, resource=resource.name)\n            self.backend.add_vertex(action)\n            self.backend.add_edge(EdgeType.MEMBER_OF, action, resource)\n\n    def remove_resource(self, resource: Resource) -&gt; None:\n        \"\"\"Remove a resource from the permission graph.\"\"\"\n        actions = self.backend.get_vertices_to(resource)\n        for action in actions:\n            self.backend.remove_vertex(action)\n        self.backend.remove_vertex(resource)\n\n    def add_group(self, group: Group):\n        \"\"\"Add a group to the permission graph.\"\"\"\n        self.backend.add_vertex(group)\n\n    def remove_group(self, group: Group):\n        \"\"\"Remove a group from the permission graph.\"\"\"\n        self.backend.remove_vertex(group)\n\n    def allow(self, actor: Actor | Group | Action, action: Action):\n        \"\"\"Grant actor or group permission to take action on resource or group.\"\"\"\n        self.backend.add_edge(EdgeType.ALLOW, source=actor, target=action)\n\n    def deny(self, actor: Actor | Group | Action, action: Action):\n        \"\"\"Deny actor or group permission to take action on resource or group.\"\"\"\n        self.backend.add_edge(EdgeType.DENY, source=actor, target=action)\n\n    def revoke(self, actor: Actor | Group | Action, action: Action):\n        \"\"\"Revoke a permission (either allow or deny).\"\"\"\n        self.backend.remove_edge(actor, action)\n\n    def add_actor_to_group(self, actor: Actor, group: Group):\n        \"\"\"Add a actor to a group.\"\"\"\n        self.backend.add_edge(EdgeType.MEMBER_OF, source=actor, target=group)\n\n    def remove_actor_from_group(self, actor: Actor, group: Group):\n        \"\"\"Remove a actor from a group.\"\"\"\n        self.backend.remove_edge(source=actor, target=group)\n\n    def paths_to_targets(\n        self,\n        source: Vertex,\n        target_vtype: Type | tuple[Type],\n        prefix: list[Vertex],\n        paths: list[list[Vertex]],\n        reverse=False,\n    ) -&gt; list[list[Vertex]]:\n        \"\"\"Finds paths from a source vertex to other vertices of specified type.\n\n        This is a helpful utility for traversing the permissions graph. You can\n        use it, for example, to find all of the Actions granted to a User or\n        Group, or to find all of the users and groups allowed to perform some\n        Action.\n\n        To prevent unexpectedly expensive invocations, search along a path will\n        not proceed beyond the first occurrence of a target_vtype. This means\n        that if looking for all Actions that a user is granted permission to\n        access, it will return any Actions that are granted directly to a User\n        or to a Group the user is a part of. However, it will not return\n        downstream actions granted via action propagation. Similarly, if looking\n        for all Users and Groups with access to a particular Resource, the search\n        will stop will return a path to a Group, but it will not return a path\n        to all users within that group. Expanding those paths is possible\n        through subsequent invocations of this function.\n\n        Args:\n            source: The source vertex to find paths from\n            target_vtype: The type(s) of vertices to look for. For any path,\n                search will terminate with first node of specified type.\n            prefix: The nodes already part of this path\n            paths: list to which to append paths\n            reverse: if True, will look backwards through the directed graph\n                (default False).\n        \"\"\"\n        if reverse:\n            targets = self.backend.get_vertices_to(source)\n        else:\n            targets = self.backend.get_vertices_from(source)\n\n        # Recursively invoke on children\n        new_prefix = prefix + [source]\n        for target in targets:\n            if isinstance(target, target_vtype):\n                path = new_prefix + [target]\n                paths.append(path[::-1])\n            else:\n                self._paths_to_targets(\n                    target, target_vtype=target_vtype, prefix=new_prefix, paths=paths, reverse=reverse\n                )\n\n        return paths\n\n    def action_is_authorized(self, actor: Actor, action: str) -&gt; bool:\n        \"\"\"Authorize actor to perform action on resource.\"\"\"\n        shortest_paths = self.backend.shortest_paths(actor, action)\n        if len(shortest_paths) == 0:\n            return False\n        elif len(shortest_paths) == 1:\n            shortest_path = shortest_paths[0]\n            return self.backend.get_edge_type(shortest_path[-2], shortest_path[-1]) == EdgeType.ALLOW\n        else:\n            match self.tie_breaker_policy:\n                case TieBreakerPolicy.ANY_ALLOW:\n                    policy = any\n                case TieBreakerPolicy.ALL_ALLOW:\n                    policy = all\n            return policy(self.backend.get_edge_type(path[-2], path[-1]) == EdgeType.ALLOW for path in shortest_paths)\n\n    def update_resource_type_actions(self, resource_type_name: str, new_actions: list[str]):\n        \"\"\"Update the set of actions supported by ResourceType.\n\n        This method updates the ResourceType definition, and updates all existing\n        resources of this resource type.\n\n        Args:\n            resource_type_name: The name of the resource type to update\n            new_actions: A full list of actions supported by this resource type\n        \"\"\"\n        resource_type = self.backend.vertex_factory(f\"resource_type:{resource_type_name}\")\n        self.backend.update_vertex_attributes(resource_type=resource_type, actions=new_actions)\n        old_action_set = set(resource_type.actions)\n        new_action_set = set(new_actions)\n        actions_to_add = new_action_set.difference(old_action_set)\n        actions_to_remove = old_action_set.difference(new_action_set)\n        resources = self.backend.get_vertices_to(resource_type)\n        for resource in resources:\n            # Add actions_to_add\n            for action_name in actions_to_add:\n                action = Action(name=action_name, resource_type=resource_type_name, resource=resource.name)\n                self.backend.add_vertex(action)\n                self.backend.add_edge(EdgeType.MEMBER_OF, action, resource)\n\n            # Remove actions_to_remove\n            for action_name in actions_to_remove:\n                action = Action(\n                    name=action_name,\n                    resource_type=resource_type_name,\n                    resource=resource.name,\n                )\n                self.backend.remove_vertex(action)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.__init__","title":"<code>__init__(backend=None, tie_breaker_policy=TieBreakerPolicy.ANY_ALLOW)</code>","text":"<p>Initialize a new PermissionGraph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def __init__(\n    self, backend: PermissionGraphBackend = None, tie_breaker_policy: TieBreakerPolicy = TieBreakerPolicy.ANY_ALLOW\n) -&gt; None:\n    \"\"\"Initialize a new PermissionGraph.\"\"\"\n    if backend is None:\n        backend = IGraphMemoryBackend()\n    self.backend = backend\n    self.tie_breaker_policy = tie_breaker_policy\n    self._resource_type_map = {}\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.action_is_authorized","title":"<code>action_is_authorized(actor, action)</code>","text":"<p>Authorize actor to perform action on resource.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def action_is_authorized(self, actor: Actor, action: str) -&gt; bool:\n    \"\"\"Authorize actor to perform action on resource.\"\"\"\n    shortest_paths = self.backend.shortest_paths(actor, action)\n    if len(shortest_paths) == 0:\n        return False\n    elif len(shortest_paths) == 1:\n        shortest_path = shortest_paths[0]\n        return self.backend.get_edge_type(shortest_path[-2], shortest_path[-1]) == EdgeType.ALLOW\n    else:\n        match self.tie_breaker_policy:\n            case TieBreakerPolicy.ANY_ALLOW:\n                policy = any\n            case TieBreakerPolicy.ALL_ALLOW:\n                policy = all\n        return policy(self.backend.get_edge_type(path[-2], path[-1]) == EdgeType.ALLOW for path in shortest_paths)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.add_actor","title":"<code>add_actor(actor)</code>","text":"<p>Add a actor to the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def add_actor(self, actor: Actor | str) -&gt; None:\n    \"\"\"Add a actor to the permission graph.\"\"\"\n    self.backend.add_vertex(actor)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.add_actor_to_group","title":"<code>add_actor_to_group(actor, group)</code>","text":"<p>Add a actor to a group.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def add_actor_to_group(self, actor: Actor, group: Group):\n    \"\"\"Add a actor to a group.\"\"\"\n    self.backend.add_edge(EdgeType.MEMBER_OF, source=actor, target=group)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.add_group","title":"<code>add_group(group)</code>","text":"<p>Add a group to the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def add_group(self, group: Group):\n    \"\"\"Add a group to the permission graph.\"\"\"\n    self.backend.add_vertex(group)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.add_resource","title":"<code>add_resource(resource)</code>","text":"<p>Add a resource to the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def add_resource(self, resource: Resource) -&gt; None:\n    \"\"\"Add a resource to the permission graph.\"\"\"\n    resource_type = self.backend.vertex_factory(f\"resource_type:{resource.resource_type}\")\n    self.backend.add_vertex(resource)\n    self.backend.add_edge(EdgeType.MEMBER_OF, resource, resource_type)\n    for action_name in resource_type.actions:\n        action = Action(name=action_name, resource_type=resource.resource_type, resource=resource.name)\n        self.backend.add_vertex(action)\n        self.backend.add_edge(EdgeType.MEMBER_OF, action, resource)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.add_resource_type","title":"<code>add_resource_type(resource_type)</code>","text":"<p>Register a resource type to the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def add_resource_type(self, resource_type: ResourceType):\n    \"\"\"Register a resource type to the permission graph.\"\"\"\n    self.backend.add_vertex(resource_type, actions=resource_type.actions)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.allow","title":"<code>allow(actor, action)</code>","text":"<p>Grant actor or group permission to take action on resource or group.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def allow(self, actor: Actor | Group | Action, action: Action):\n    \"\"\"Grant actor or group permission to take action on resource or group.\"\"\"\n    self.backend.add_edge(EdgeType.ALLOW, source=actor, target=action)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.deny","title":"<code>deny(actor, action)</code>","text":"<p>Deny actor or group permission to take action on resource or group.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def deny(self, actor: Actor | Group | Action, action: Action):\n    \"\"\"Deny actor or group permission to take action on resource or group.\"\"\"\n    self.backend.add_edge(EdgeType.DENY, source=actor, target=action)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.paths_to_targets","title":"<code>paths_to_targets(source, target_vtype, prefix, paths, reverse=False)</code>","text":"<p>Finds paths from a source vertex to other vertices of specified type.</p> <p>This is a helpful utility for traversing the permissions graph. You can use it, for example, to find all of the Actions granted to a User or Group, or to find all of the users and groups allowed to perform some Action.</p> <p>To prevent unexpectedly expensive invocations, search along a path will not proceed beyond the first occurrence of a target_vtype. This means that if looking for all Actions that a user is granted permission to access, it will return any Actions that are granted directly to a User or to a Group the user is a part of. However, it will not return downstream actions granted via action propagation. Similarly, if looking for all Users and Groups with access to a particular Resource, the search will stop will return a path to a Group, but it will not return a path to all users within that group. Expanding those paths is possible through subsequent invocations of this function.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Vertex</code> <p>The source vertex to find paths from</p> required <code>target_vtype</code> <code>Type | tuple[Type]</code> <p>The type(s) of vertices to look for. For any path, search will terminate with first node of specified type.</p> required <code>prefix</code> <code>list[Vertex]</code> <p>The nodes already part of this path</p> required <code>paths</code> <code>list[list[Vertex]]</code> <p>list to which to append paths</p> required <code>reverse</code> <p>if True, will look backwards through the directed graph (default False).</p> <code>False</code> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def paths_to_targets(\n    self,\n    source: Vertex,\n    target_vtype: Type | tuple[Type],\n    prefix: list[Vertex],\n    paths: list[list[Vertex]],\n    reverse=False,\n) -&gt; list[list[Vertex]]:\n    \"\"\"Finds paths from a source vertex to other vertices of specified type.\n\n    This is a helpful utility for traversing the permissions graph. You can\n    use it, for example, to find all of the Actions granted to a User or\n    Group, or to find all of the users and groups allowed to perform some\n    Action.\n\n    To prevent unexpectedly expensive invocations, search along a path will\n    not proceed beyond the first occurrence of a target_vtype. This means\n    that if looking for all Actions that a user is granted permission to\n    access, it will return any Actions that are granted directly to a User\n    or to a Group the user is a part of. However, it will not return\n    downstream actions granted via action propagation. Similarly, if looking\n    for all Users and Groups with access to a particular Resource, the search\n    will stop will return a path to a Group, but it will not return a path\n    to all users within that group. Expanding those paths is possible\n    through subsequent invocations of this function.\n\n    Args:\n        source: The source vertex to find paths from\n        target_vtype: The type(s) of vertices to look for. For any path,\n            search will terminate with first node of specified type.\n        prefix: The nodes already part of this path\n        paths: list to which to append paths\n        reverse: if True, will look backwards through the directed graph\n            (default False).\n    \"\"\"\n    if reverse:\n        targets = self.backend.get_vertices_to(source)\n    else:\n        targets = self.backend.get_vertices_from(source)\n\n    # Recursively invoke on children\n    new_prefix = prefix + [source]\n    for target in targets:\n        if isinstance(target, target_vtype):\n            path = new_prefix + [target]\n            paths.append(path[::-1])\n        else:\n            self._paths_to_targets(\n                target, target_vtype=target_vtype, prefix=new_prefix, paths=paths, reverse=reverse\n            )\n\n    return paths\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.remove_actor","title":"<code>remove_actor(actor)</code>","text":"<p>Remove a actor from the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def remove_actor(self, actor: Actor) -&gt; None:\n    \"\"\"Remove a actor from the permission graph.\"\"\"\n    self.backend.remove_vertex(actor)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.remove_actor_from_group","title":"<code>remove_actor_from_group(actor, group)</code>","text":"<p>Remove a actor from a group.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def remove_actor_from_group(self, actor: Actor, group: Group):\n    \"\"\"Remove a actor from a group.\"\"\"\n    self.backend.remove_edge(source=actor, target=group)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.remove_group","title":"<code>remove_group(group)</code>","text":"<p>Remove a group from the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def remove_group(self, group: Group):\n    \"\"\"Remove a group from the permission graph.\"\"\"\n    self.backend.remove_vertex(group)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.remove_resource","title":"<code>remove_resource(resource)</code>","text":"<p>Remove a resource from the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def remove_resource(self, resource: Resource) -&gt; None:\n    \"\"\"Remove a resource from the permission graph.\"\"\"\n    actions = self.backend.get_vertices_to(resource)\n    for action in actions:\n        self.backend.remove_vertex(action)\n    self.backend.remove_vertex(resource)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.remove_resource_type","title":"<code>remove_resource_type(resource_type)</code>","text":"<p>Remove a resource type from the permission graph.</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def remove_resource_type(self, resource_type: ResourceType):\n    \"\"\"Remove a resource type from the permission graph.\"\"\"\n    for resource in self.backend.get_vertices_to(resource_type):\n        self.remove_resource(resource)\n    self.backend.remove_vertex(resource_type)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.revoke","title":"<code>revoke(actor, action)</code>","text":"<p>Revoke a permission (either allow or deny).</p> Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def revoke(self, actor: Actor | Group | Action, action: Action):\n    \"\"\"Revoke a permission (either allow or deny).\"\"\"\n    self.backend.remove_edge(actor, action)\n</code></pre>"},{"location":"reference/permission_graph/permission_graph/#permission_graph.permission_graph.PermissionGraph.update_resource_type_actions","title":"<code>update_resource_type_actions(resource_type_name, new_actions)</code>","text":"<p>Update the set of actions supported by ResourceType.</p> <p>This method updates the ResourceType definition, and updates all existing resources of this resource type.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type_name</code> <code>str</code> <p>The name of the resource type to update</p> required <code>new_actions</code> <code>list[str]</code> <p>A full list of actions supported by this resource type</p> required Source code in <code>src/permission_graph/permission_graph.py</code> <pre><code>def update_resource_type_actions(self, resource_type_name: str, new_actions: list[str]):\n    \"\"\"Update the set of actions supported by ResourceType.\n\n    This method updates the ResourceType definition, and updates all existing\n    resources of this resource type.\n\n    Args:\n        resource_type_name: The name of the resource type to update\n        new_actions: A full list of actions supported by this resource type\n    \"\"\"\n    resource_type = self.backend.vertex_factory(f\"resource_type:{resource_type_name}\")\n    self.backend.update_vertex_attributes(resource_type=resource_type, actions=new_actions)\n    old_action_set = set(resource_type.actions)\n    new_action_set = set(new_actions)\n    actions_to_add = new_action_set.difference(old_action_set)\n    actions_to_remove = old_action_set.difference(new_action_set)\n    resources = self.backend.get_vertices_to(resource_type)\n    for resource in resources:\n        # Add actions_to_add\n        for action_name in actions_to_add:\n            action = Action(name=action_name, resource_type=resource_type_name, resource=resource.name)\n            self.backend.add_vertex(action)\n            self.backend.add_edge(EdgeType.MEMBER_OF, action, resource)\n\n        # Remove actions_to_remove\n        for action_name in actions_to_remove:\n            action = Action(\n                name=action_name,\n                resource_type=resource_type_name,\n                resource=resource.name,\n            )\n            self.backend.remove_vertex(action)\n</code></pre>"},{"location":"reference/permission_graph/structs/","title":"structs","text":""},{"location":"reference/permission_graph/structs/#permission_graph.structs.Action","title":"<code>Action</code>","text":"<p>             Bases: <code>Vertex</code></p> <p>A vertex type representing an action on a resource.</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class Action(Vertex):\n    \"\"\"A vertex type representing an action on a resource.\"\"\"\n\n    vtype: str = Field(default=\"action\")\n    resource_type: str\n    resource: str\n\n    @property\n    def id(self) -&gt; str:\n        return f\"{self.vtype}:{self.resource_type}:{self.resource}:{self.name}\"\n\n    @classmethod\n    def from_id(cls, vertex_id: str) -&gt; Self:\n        vtype, resource_type, resource, name = vertex_id.split(\":\")\n        return cls(vtype=vtype, resource_type=resource_type, resource=resource, name=name)\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.Actor","title":"<code>Actor</code>","text":"<p>             Bases: <code>Vertex</code></p> <p>A vertex type representing an actor.</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class Actor(Vertex):\n    \"\"\"A vertex type representing an actor.\"\"\"\n\n    vtype: str = Field(default=\"actor\")\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.EdgeType","title":"<code>EdgeType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Type for edges.</p> <p>Values</p> <ul> <li><code>ALLOW</code>: allow an actor to take an action</li> <li><code>DENY</code>: deny an actor from taking an action</li> <li><code>MEMBER_OF</code>: indicate membership in a collection</li> </ul> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class EdgeType(Enum):\n    \"\"\"Type for edges.\n\n    Values\n\n    - `ALLOW`: allow an actor to take an action\n    - `DENY`: deny an actor from taking an action\n    - `MEMBER_OF`: indicate membership in a collection\n    \"\"\"\n\n    ALLOW = \"ALLOW\"\n    DENY = \"DENY\"\n    MEMBER_OF = \"MEMBER_OF\"\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.Effect","title":"<code>Effect</code>","text":"<p>             Bases: <code>Enum</code></p> <p>The effect of a permission policy.</p> <p>Values</p> <ul> <li><code>ALLOW</code>: action is allowed</li> <li><code>DENY</code>: action is not allowed</li> </ul> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class Effect(Enum):\n    \"\"\"The effect of a permission policy.\n\n    Values\n\n    - `ALLOW`: action is allowed\n    - `DENY`: action is not allowed\n    \"\"\"\n\n    ALLOW = \"ALLOW\"\n    DENY = \"DENY\"\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.Group","title":"<code>Group</code>","text":"<p>             Bases: <code>Vertex</code></p> <p>A vertex type representing a group of Actors.</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class Group(Vertex):\n    \"\"\"A vertex type representing a group of Actors.\"\"\"\n\n    vtype: str = Field(default=\"group\")\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.PermissionPolicy","title":"<code>PermissionPolicy</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A permission policy statement.</p> <p>PermissionPolicy objects represent a permission statement linking a user to an action.</p> <p>Attributes:</p> Name Type Description <code>action</code> <code>Action</code> <p>The policy's action</p> <code>actor</code> <code>Actor</code> <p>The policy's actor</p> <code>resource</code> <code>Resource</code> <p>The resource being acted upon</p> <code>resourceType</code> <code>ResourceType</code> <p>The resource type of the resource being acted upon</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class PermissionPolicy(BaseModel):\n    \"\"\"A permission policy statement.\n\n    PermissionPolicy objects represent a permission statement linking a user\n    to an action.\n\n    Attributes:\n        action: The policy's action\n        actor: The policy's actor\n        resource: The resource being acted upon\n        resourceType: The resource type of the resource being acted upon\n    \"\"\"\n\n    action: Action\n    actor: Actor\n    group: Group | None\n    resource: Resource\n    resourceType: ResourceType\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.Resource","title":"<code>Resource</code>","text":"<p>             Bases: <code>Vertex</code></p> <p>A vertex type representing a resource.</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class Resource(Vertex):\n    \"\"\"A vertex type representing a resource.\"\"\"\n\n    vtype: str = Field(default=\"resource\")\n    resource_type: str\n\n    @property\n    def id(self) -&gt; str:\n        return f\"{self.vtype}:{self.resource_type}:{self.name}\"\n\n    @classmethod\n    def from_id(cls, vertex_id: str) -&gt; Self:\n        vtype, resource_type, name = vertex_id.split(\":\")\n        return cls(vtype=vtype, resource_type=resource_type, name=name)\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.ResourceType","title":"<code>ResourceType</code>","text":"<p>             Bases: <code>Vertex</code></p> <p>A vertex type representing resource types.</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class ResourceType(Vertex):\n    \"\"\"A vertex type representing resource types.\"\"\"\n\n    vtype: str = Field(default=\"resource_type\")\n    actions: list[str]\n\n    @classmethod\n    def from_id(cls, vertex_id: str, actions):\n        vtype, name = vertex_id.split(\":\")\n        return cls(vtype=vtype, name=name, actions=actions)\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.TieBreakerPolicy","title":"<code>TieBreakerPolicy</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Policy for breaking ties in permissions graph.</p> <p>Values</p> <ul> <li><code>ANY_ALLOW</code>: allow if any of the candidate paths allow the action</li> <li><code>ALL_ALLOW</code>: allow only if all of the candidate paths allow the action</li> </ul> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class TieBreakerPolicy(Enum):\n    \"\"\"Policy for breaking ties in permissions graph.\n\n    Values\n\n    - `ANY_ALLOW`: allow if any of the candidate paths allow the action\n    - `ALL_ALLOW`: allow only if all of the candidate paths allow the action\n    \"\"\"\n\n    ANY_ALLOW = \"ANY_ALLOW\"\n    ALL_ALLOW = \"ALL_ALLOW\"\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.Vertex","title":"<code>Vertex</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>A vertex in the permission graph.</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>class Vertex(BaseModel):\n    \"\"\"A vertex in the permission graph.\"\"\"\n\n    vtype: str\n    name: str\n\n    @property\n    def id(self) -&gt; str:\n        return f\"{self.vtype}:{self.name}\"\n\n    @classmethod\n    def from_id(cls, vertex_id: str) -&gt; str:\n        \"\"\"Return an instance of this class from a vertex id.\"\"\"\n        vtype, name = vertex_id.split(\":\")\n        return cls(vtype=vtype, name=name)\n\n    @staticmethod\n    def factory(vertex_id: str, **kwargs) -&gt; Self:\n        \"\"\"Return a vertex object given vtype and vertex_id.\n\n        Args:\n            vtype: The type of the vertex (`user`, `action`, `group`, `resource`)\n            vertex_id: The id of the vertex\n        \"\"\"\n        vtype_map = {\"actor\": Actor, \"resource\": Resource, \"action\": Action, \"group\": Group}\n        vtype = vertex_id.split(\":\")[0]\n        return vtype_map[vtype].from_id(vertex_id, **kwargs)\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.Vertex.factory","title":"<code>factory(vertex_id, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Return a vertex object given vtype and vertex_id.</p> <p>Parameters:</p> Name Type Description Default <code>vtype</code> <p>The type of the vertex (<code>user</code>, <code>action</code>, <code>group</code>, <code>resource</code>)</p> required <code>vertex_id</code> <code>str</code> <p>The id of the vertex</p> required Source code in <code>src/permission_graph/structs.py</code> <pre><code>@staticmethod\ndef factory(vertex_id: str, **kwargs) -&gt; Self:\n    \"\"\"Return a vertex object given vtype and vertex_id.\n\n    Args:\n        vtype: The type of the vertex (`user`, `action`, `group`, `resource`)\n        vertex_id: The id of the vertex\n    \"\"\"\n    vtype_map = {\"actor\": Actor, \"resource\": Resource, \"action\": Action, \"group\": Group}\n    vtype = vertex_id.split(\":\")[0]\n    return vtype_map[vtype].from_id(vertex_id, **kwargs)\n</code></pre>"},{"location":"reference/permission_graph/structs/#permission_graph.structs.Vertex.from_id","title":"<code>from_id(vertex_id)</code>  <code>classmethod</code>","text":"<p>Return an instance of this class from a vertex id.</p> Source code in <code>src/permission_graph/structs.py</code> <pre><code>@classmethod\ndef from_id(cls, vertex_id: str) -&gt; str:\n    \"\"\"Return an instance of this class from a vertex id.\"\"\"\n    vtype, name = vertex_id.split(\":\")\n    return cls(vtype=vtype, name=name)\n</code></pre>"},{"location":"reference/permission_graph/backends/","title":"backends","text":""},{"location":"reference/permission_graph/backends/base/","title":"base","text":""},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend","title":"<code>PermissionGraphBackend</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for PermissionGraph interface.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>class PermissionGraphBackend(abc.ABC):\n    \"\"\"Base class for PermissionGraph interface.\"\"\"\n\n    @abc.abstractmethod\n    def add_vertex(self, vertex: Vertex, **kwargs) -&gt; None:\n        \"\"\"Add a vertex to the permission graph.\n\n        Raises ValueError if vertex already exists.\n        \"\"\"\n\n    @abc.abstractmethod\n    def remove_vertex(self, vertex: Vertex, **kwargs) -&gt; None:\n        \"\"\"Remove a vertex from the permission graph.\"\"\"\n\n    @abc.abstractmethod\n    def vertex_exists(self, vertex: Vertex) -&gt; bool:\n        \"\"\"Check if a vertex with vtype=vtype and id=id already exists.\"\"\"\n\n    @abc.abstractmethod\n    def get_vertices_to(self, vertex: Vertex) -&gt; list[Vertex]:\n        \"\"\"Get all vertices that target a vertex.\"\"\"\n\n    @abc.abstractmethod\n    def get_vertices_from(self, vertex: Vertex) -&gt; list[Vertex]:\n        \"\"\"Get all vertices that a vertex targets.\"\"\"\n\n    @abc.abstractmethod\n    def update_vertex_attributes(self, vertex: Vertex, **kwargs):\n        \"\"\"Update one or more attributes of a vertex.\"\"\"\n\n    @abc.abstractmethod\n    def add_edge(self, etype: str, source: Vertex, target: Vertex, **kwargs: Any) -&gt; None:\n        \"\"\"Add a edge to the permission graph.\n\n        Args:\n            etype: edge type (one of 'member_of', 'allow', 'deny')\n            source: source vertex\n            target: target vertex\n            **kwargs: addition attributes to add to edge\n\n        Raises ValueError if an edge from source to target already exists.\n        \"\"\"\n\n    @abc.abstractmethod\n    def edge_exists(self, source: Vertex, target: Vertex) -&gt; bool:\n        \"\"\"Return True if edge exists.\"\"\"\n\n    @abc.abstractmethod\n    def remove_edge(self, source: Vertex, target: Vertex) -&gt; None:\n        \"\"\"Remove an edge from the permission graph.\"\"\"\n\n    @abc.abstractmethod\n    def shortest_paths(self, source: Vertex, target: Vertex) -&gt; list[list[Vertex]]:\n        \"\"\"Return the lists of vertices that make the shortest paths from source to target.\n\n        Returns:\n            - If there is a true shortest path (no ties), return a list containing one element\n                (the shortest path).\n            - Otherwise, return a list containing all of the paths with length equal to the\n                shortest path.\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_edge_type(self, source: Vertex, target: Vertex) -&gt; EdgeType:\n        \"\"\"Return the EdgeType of the edge connecting two vertices.\n\n        Raises ValueError if there is no edge between the two vertices.\n        \"\"\"\n\n    @abc.abstractmethod\n    def vertex_factory(self, vertex_id) -&gt; Vertex:\n        \"\"\"Return a vertex from a vertex id.\n\n        Given a vertex id, return an vertex object of the appropriate subclass.\n        \"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.add_edge","title":"<code>add_edge(etype, source, target, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Add a edge to the permission graph.</p> <p>Parameters:</p> Name Type Description Default <code>etype</code> <code>str</code> <p>edge type (one of 'member_of', 'allow', 'deny')</p> required <code>source</code> <code>Vertex</code> <p>source vertex</p> required <code>target</code> <code>Vertex</code> <p>target vertex</p> required <code>**kwargs</code> <code>Any</code> <p>addition attributes to add to edge</p> <code>{}</code> <p>Raises ValueError if an edge from source to target already exists.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef add_edge(self, etype: str, source: Vertex, target: Vertex, **kwargs: Any) -&gt; None:\n    \"\"\"Add a edge to the permission graph.\n\n    Args:\n        etype: edge type (one of 'member_of', 'allow', 'deny')\n        source: source vertex\n        target: target vertex\n        **kwargs: addition attributes to add to edge\n\n    Raises ValueError if an edge from source to target already exists.\n    \"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.add_vertex","title":"<code>add_vertex(vertex, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Add a vertex to the permission graph.</p> <p>Raises ValueError if vertex already exists.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef add_vertex(self, vertex: Vertex, **kwargs) -&gt; None:\n    \"\"\"Add a vertex to the permission graph.\n\n    Raises ValueError if vertex already exists.\n    \"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.edge_exists","title":"<code>edge_exists(source, target)</code>  <code>abstractmethod</code>","text":"<p>Return True if edge exists.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef edge_exists(self, source: Vertex, target: Vertex) -&gt; bool:\n    \"\"\"Return True if edge exists.\"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.get_edge_type","title":"<code>get_edge_type(source, target)</code>  <code>abstractmethod</code>","text":"<p>Return the EdgeType of the edge connecting two vertices.</p> <p>Raises ValueError if there is no edge between the two vertices.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef get_edge_type(self, source: Vertex, target: Vertex) -&gt; EdgeType:\n    \"\"\"Return the EdgeType of the edge connecting two vertices.\n\n    Raises ValueError if there is no edge between the two vertices.\n    \"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.get_vertices_from","title":"<code>get_vertices_from(vertex)</code>  <code>abstractmethod</code>","text":"<p>Get all vertices that a vertex targets.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef get_vertices_from(self, vertex: Vertex) -&gt; list[Vertex]:\n    \"\"\"Get all vertices that a vertex targets.\"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.get_vertices_to","title":"<code>get_vertices_to(vertex)</code>  <code>abstractmethod</code>","text":"<p>Get all vertices that target a vertex.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef get_vertices_to(self, vertex: Vertex) -&gt; list[Vertex]:\n    \"\"\"Get all vertices that target a vertex.\"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.remove_edge","title":"<code>remove_edge(source, target)</code>  <code>abstractmethod</code>","text":"<p>Remove an edge from the permission graph.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef remove_edge(self, source: Vertex, target: Vertex) -&gt; None:\n    \"\"\"Remove an edge from the permission graph.\"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.remove_vertex","title":"<code>remove_vertex(vertex, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Remove a vertex from the permission graph.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef remove_vertex(self, vertex: Vertex, **kwargs) -&gt; None:\n    \"\"\"Remove a vertex from the permission graph.\"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.shortest_paths","title":"<code>shortest_paths(source, target)</code>  <code>abstractmethod</code>","text":"<p>Return the lists of vertices that make the shortest paths from source to target.</p> <p>Returns:</p> Type Description <code>list[list[Vertex]]</code> <ul> <li>If there is a true shortest path (no ties), return a list containing one element (the shortest path).</li> </ul> <code>list[list[Vertex]]</code> <ul> <li>Otherwise, return a list containing all of the paths with length equal to the shortest path.</li> </ul> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef shortest_paths(self, source: Vertex, target: Vertex) -&gt; list[list[Vertex]]:\n    \"\"\"Return the lists of vertices that make the shortest paths from source to target.\n\n    Returns:\n        - If there is a true shortest path (no ties), return a list containing one element\n            (the shortest path).\n        - Otherwise, return a list containing all of the paths with length equal to the\n            shortest path.\n    \"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.update_vertex_attributes","title":"<code>update_vertex_attributes(vertex, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Update one or more attributes of a vertex.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef update_vertex_attributes(self, vertex: Vertex, **kwargs):\n    \"\"\"Update one or more attributes of a vertex.\"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.vertex_exists","title":"<code>vertex_exists(vertex)</code>  <code>abstractmethod</code>","text":"<p>Check if a vertex with vtype=vtype and id=id already exists.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef vertex_exists(self, vertex: Vertex) -&gt; bool:\n    \"\"\"Check if a vertex with vtype=vtype and id=id already exists.\"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/base/#permission_graph.backends.base.PermissionGraphBackend.vertex_factory","title":"<code>vertex_factory(vertex_id)</code>  <code>abstractmethod</code>","text":"<p>Return a vertex from a vertex id.</p> <p>Given a vertex id, return an vertex object of the appropriate subclass.</p> Source code in <code>src/permission_graph/backends/base.py</code> <pre><code>@abc.abstractmethod\ndef vertex_factory(self, vertex_id) -&gt; Vertex:\n    \"\"\"Return a vertex from a vertex id.\n\n    Given a vertex id, return an vertex object of the appropriate subclass.\n    \"\"\"\n</code></pre>"},{"location":"reference/permission_graph/backends/igraph/","title":"igraph","text":""},{"location":"reference/permission_graph/backends/igraph/#permission_graph.backends.igraph.IGraphMemoryBackend","title":"<code>IGraphMemoryBackend</code>","text":"<p>             Bases: <code>PermissionGraphBackend</code></p> <p>IGraph based PermissionGraphBackend implementation.</p> Source code in <code>src/permission_graph/backends/igraph.py</code> <pre><code>class IGraphMemoryBackend(PermissionGraphBackend):\n    \"\"\"IGraph based PermissionGraphBackend implementation.\"\"\"\n\n    def __init__(self):\n        self._g = igraph.Graph(directed=True)\n\n    def add_vertex(self, vertex: Vertex, **kwargs) -&gt; None:\n        try:\n            self._get_igraph_vertex(vertex.id)\n        except ValueError:\n            self._g.add_vertex(f\"{vertex.id}\", vtype=vertex.vtype, **kwargs)\n        else:\n            raise ValueError(f\"Vertex already exists: {vertex}\")\n\n    def remove_vertex(self, vertex: Vertex) -&gt; None:\n        v = self._g.vs.find(vertex.id)\n        self._g.delete_vertices(v.index)\n\n    def update_vertex_attributes(self, vertex: Vertex, **kwargs: Any) -&gt; None:\n        v = self._g.vs.find(vertex.id)\n        for key, value in kwargs.items():\n            v[key] = value\n\n    def get_vertices_to(self, vertex: Vertex) -&gt; list[Vertex]:\n        v = self._get_igraph_vertex(vertex.id)\n        sources = [self.vertex_factory(edge.source_vertex[\"name\"]) for edge in self._g.es.select(_target=v)]\n        return sources\n\n    def get_vertices_from(self, vertex: Vertex) -&gt; list[Vertex]:\n        v = self._get_igraph_vertex(vertex.id)\n        sources = [self.vertex_factory(edge.target_vertex[\"name\"]) for edge in self._g.es.select(_source=v)]\n        return sources\n\n    def _get_igraph_vertex(self, vertex_id: str) -&gt; igraph.Vertex:\n        \"\"\"Get an igraph vertex given a vertex id.\"\"\"\n        return self._g.vs.find(vertex_id)\n\n    def vertex_exists(self, vertex: Vertex) -&gt; bool:\n        \"\"\"Return True if a vertex wit hthat id already exists.\"\"\"\n        try:\n            self._get_igraph_vertex(vertex.id)\n            return True\n        except ValueError:\n            return False\n\n    def add_edge(self, etype: EdgeType, source: Vertex, target: Vertex, **kwargs) -&gt; None:\n        v1 = self._get_igraph_vertex(source.id)\n        v2 = self._get_igraph_vertex(target.id)\n        try:\n            self._get_igraph_edge(source, target)\n        except ValueError:\n            extra_attrs = {attr: [val] for attr, val in kwargs.items()}\n            self._g.add_edges([(v1, v2)], attributes=dict(etype=[etype.value], **extra_attrs))\n        else:\n            raise ValueError(f\"There is already an edge between vertices '{v1.index}' and '{v2.index}'\")\n\n    def _get_igraph_edge(self, source: Vertex, target: Vertex) -&gt; igraph.Edge:\n        \"\"\"Return an IGraph edge given edge definition.\"\"\"\n        v1 = self._get_igraph_vertex(source.id)\n        v2 = self._get_igraph_vertex(target.id)\n        return self._g.es.find(_source=v1.index, _target=v2.index)\n\n    def edge_exists(self, source: Vertex, target: Vertex) -&gt; bool:\n        \"\"\"Return True if there is an edge between source and target.\"\"\"\n        try:\n            self._get_igraph_edge(source, target)\n            return True\n        except ValueError:\n            return False\n\n    def remove_edge(self, source: Vertex, target: Vertex) -&gt; None:\n        \"\"\"Remove an edge from the permission graph.\"\"\"\n        e = self._get_igraph_edge(source, target)\n        if e is not None:\n            self._g.delete_edges(e.index)\n\n    def shortest_paths(self, source: Vertex, target: Vertex) -&gt; list[list[Vertex]]:\n        \"\"\"Return all shortest paths from source to target.\"\"\"\n        v1 = self._get_igraph_vertex(source.id)\n        v2 = self._get_igraph_vertex(target.id)\n        paths = self._g.get_all_shortest_paths(v1, v2)\n        output = []\n        for path in paths:\n            vertex_path = []\n            for index in path:\n                v = self._g.vs[index]\n                vertex_path.append(self.vertex_factory(v[\"name\"]))\n            output.append(vertex_path)\n        return output\n\n    def get_edge_type(self, source: Vertex, target: Vertex) -&gt; EdgeType:\n        \"\"\"Get the type of edge from source to target.\"\"\"\n        e = self._get_igraph_edge(source, target)\n        if e is None:\n            raise ValueError(f\"There is no edge from {source} to {target}.\")\n        return EdgeType(e[\"etype\"])\n\n    def vertex_factory(self, vertex_id) -&gt; Vertex:\n        \"\"\"Return a vertex from a vertex id.\"\"\"\n        vtype_map = {\n            \"actor\": Actor,\n            \"resource\": Resource,\n            \"action\": Action,\n            \"group\": Group,\n            \"resource_type\": ResourceType,\n        }\n        vtype = vertex_id.split(\":\")[0]\n        v = self._get_igraph_vertex(vertex_id)\n        attributes = v.attributes()\n        attributes = {k: v for k, v in v.attributes().items() if k not in (\"vtype\", \"name\") and v is not None}\n        return vtype_map[vtype].from_id(vertex_id, **attributes)\n</code></pre>"},{"location":"reference/permission_graph/backends/igraph/#permission_graph.backends.igraph.IGraphMemoryBackend.edge_exists","title":"<code>edge_exists(source, target)</code>","text":"<p>Return True if there is an edge between source and target.</p> Source code in <code>src/permission_graph/backends/igraph.py</code> <pre><code>def edge_exists(self, source: Vertex, target: Vertex) -&gt; bool:\n    \"\"\"Return True if there is an edge between source and target.\"\"\"\n    try:\n        self._get_igraph_edge(source, target)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"reference/permission_graph/backends/igraph/#permission_graph.backends.igraph.IGraphMemoryBackend.get_edge_type","title":"<code>get_edge_type(source, target)</code>","text":"<p>Get the type of edge from source to target.</p> Source code in <code>src/permission_graph/backends/igraph.py</code> <pre><code>def get_edge_type(self, source: Vertex, target: Vertex) -&gt; EdgeType:\n    \"\"\"Get the type of edge from source to target.\"\"\"\n    e = self._get_igraph_edge(source, target)\n    if e is None:\n        raise ValueError(f\"There is no edge from {source} to {target}.\")\n    return EdgeType(e[\"etype\"])\n</code></pre>"},{"location":"reference/permission_graph/backends/igraph/#permission_graph.backends.igraph.IGraphMemoryBackend.remove_edge","title":"<code>remove_edge(source, target)</code>","text":"<p>Remove an edge from the permission graph.</p> Source code in <code>src/permission_graph/backends/igraph.py</code> <pre><code>def remove_edge(self, source: Vertex, target: Vertex) -&gt; None:\n    \"\"\"Remove an edge from the permission graph.\"\"\"\n    e = self._get_igraph_edge(source, target)\n    if e is not None:\n        self._g.delete_edges(e.index)\n</code></pre>"},{"location":"reference/permission_graph/backends/igraph/#permission_graph.backends.igraph.IGraphMemoryBackend.shortest_paths","title":"<code>shortest_paths(source, target)</code>","text":"<p>Return all shortest paths from source to target.</p> Source code in <code>src/permission_graph/backends/igraph.py</code> <pre><code>def shortest_paths(self, source: Vertex, target: Vertex) -&gt; list[list[Vertex]]:\n    \"\"\"Return all shortest paths from source to target.\"\"\"\n    v1 = self._get_igraph_vertex(source.id)\n    v2 = self._get_igraph_vertex(target.id)\n    paths = self._g.get_all_shortest_paths(v1, v2)\n    output = []\n    for path in paths:\n        vertex_path = []\n        for index in path:\n            v = self._g.vs[index]\n            vertex_path.append(self.vertex_factory(v[\"name\"]))\n        output.append(vertex_path)\n    return output\n</code></pre>"},{"location":"reference/permission_graph/backends/igraph/#permission_graph.backends.igraph.IGraphMemoryBackend.vertex_exists","title":"<code>vertex_exists(vertex)</code>","text":"<p>Return True if a vertex wit hthat id already exists.</p> Source code in <code>src/permission_graph/backends/igraph.py</code> <pre><code>def vertex_exists(self, vertex: Vertex) -&gt; bool:\n    \"\"\"Return True if a vertex wit hthat id already exists.\"\"\"\n    try:\n        self._get_igraph_vertex(vertex.id)\n        return True\n    except ValueError:\n        return False\n</code></pre>"},{"location":"reference/permission_graph/backends/igraph/#permission_graph.backends.igraph.IGraphMemoryBackend.vertex_factory","title":"<code>vertex_factory(vertex_id)</code>","text":"<p>Return a vertex from a vertex id.</p> Source code in <code>src/permission_graph/backends/igraph.py</code> <pre><code>def vertex_factory(self, vertex_id) -&gt; Vertex:\n    \"\"\"Return a vertex from a vertex id.\"\"\"\n    vtype_map = {\n        \"actor\": Actor,\n        \"resource\": Resource,\n        \"action\": Action,\n        \"group\": Group,\n        \"resource_type\": ResourceType,\n    }\n    vtype = vertex_id.split(\":\")[0]\n    v = self._get_igraph_vertex(vertex_id)\n    attributes = v.attributes()\n    attributes = {k: v for k, v in v.attributes().items() if k not in (\"vtype\", \"name\") and v is not None}\n    return vtype_map[vtype].from_id(vertex_id, **attributes)\n</code></pre>"}]}